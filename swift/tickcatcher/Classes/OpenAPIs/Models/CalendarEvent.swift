//
// CalendarEvent.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct CalendarEvent: Codable, JSONEncodable, Hashable {

    public var title: String
    public var country: String
    public var indicator: String?
    public var ticker: String?
    public var comment: String?
    public var category: String?
    public var period: String?
    public var referenceDate: String?
    public var source: String?
    public var sourceUrl: String?
    public var actual: Double?
    public var previous: Double?
    public var forecast: Double?
    public var actualRaw: Double?
    public var previousRaw: Double?
    public var forecastRaw: Double?
    public var currency: String?
    public var unit: String?
    /** A number of importance, can be -1, 0 or 1. */
    public var importance: Double
    /** Unix timestamp (ms) */
    public var ts: Double
    public var scale: String?

    public init(title: String, country: String, indicator: String? = nil, ticker: String? = nil, comment: String? = nil, category: String? = nil, period: String? = nil, referenceDate: String? = nil, source: String? = nil, sourceUrl: String? = nil, actual: Double? = nil, previous: Double? = nil, forecast: Double? = nil, actualRaw: Double? = nil, previousRaw: Double? = nil, forecastRaw: Double? = nil, currency: String? = nil, unit: String? = nil, importance: Double, ts: Double, scale: String? = nil) {
        self.title = title
        self.country = country
        self.indicator = indicator
        self.ticker = ticker
        self.comment = comment
        self.category = category
        self.period = period
        self.referenceDate = referenceDate
        self.source = source
        self.sourceUrl = sourceUrl
        self.actual = actual
        self.previous = previous
        self.forecast = forecast
        self.actualRaw = actualRaw
        self.previousRaw = previousRaw
        self.forecastRaw = forecastRaw
        self.currency = currency
        self.unit = unit
        self.importance = importance
        self.ts = ts
        self.scale = scale
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case title
        case country
        case indicator
        case ticker
        case comment
        case category
        case period
        case referenceDate = "reference_date"
        case source
        case sourceUrl = "source_url"
        case actual
        case previous
        case forecast
        case actualRaw = "actual_raw"
        case previousRaw = "previous_raw"
        case forecastRaw = "forecast_raw"
        case currency
        case unit
        case importance
        case ts
        case scale
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(title, forKey: .title)
        try container.encode(country, forKey: .country)
        try container.encodeIfPresent(indicator, forKey: .indicator)
        try container.encodeIfPresent(ticker, forKey: .ticker)
        try container.encodeIfPresent(comment, forKey: .comment)
        try container.encodeIfPresent(category, forKey: .category)
        try container.encodeIfPresent(period, forKey: .period)
        try container.encodeIfPresent(referenceDate, forKey: .referenceDate)
        try container.encodeIfPresent(source, forKey: .source)
        try container.encodeIfPresent(sourceUrl, forKey: .sourceUrl)
        try container.encodeIfPresent(actual, forKey: .actual)
        try container.encodeIfPresent(previous, forKey: .previous)
        try container.encodeIfPresent(forecast, forKey: .forecast)
        try container.encodeIfPresent(actualRaw, forKey: .actualRaw)
        try container.encodeIfPresent(previousRaw, forKey: .previousRaw)
        try container.encodeIfPresent(forecastRaw, forKey: .forecastRaw)
        try container.encodeIfPresent(currency, forKey: .currency)
        try container.encodeIfPresent(unit, forKey: .unit)
        try container.encode(importance, forKey: .importance)
        try container.encode(ts, forKey: .ts)
        try container.encodeIfPresent(scale, forKey: .scale)
    }
}

