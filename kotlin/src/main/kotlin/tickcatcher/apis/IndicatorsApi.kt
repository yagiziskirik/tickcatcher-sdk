/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package tickcatcher.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import tickcatcher.models.Adx200ResponseInner
import tickcatcher.models.AdxRequest
import tickcatcher.models.AtrRequest
import tickcatcher.models.Bbands200ResponseInner
import tickcatcher.models.BbandsRequest
import tickcatcher.models.Candle
import tickcatcher.models.CciRequest
import tickcatcher.models.EmaRequest
import tickcatcher.models.HeikenashiRequest
import tickcatcher.models.Ichimoku200ResponseInner
import tickcatcher.models.IchimokuRequest
import tickcatcher.models.KeltnerRequest
import tickcatcher.models.Macd200ResponseInner
import tickcatcher.models.MacdRequest
import tickcatcher.models.Pivot200ResponseInner
import tickcatcher.models.PivotRequest
import tickcatcher.models.PsarRequest
import tickcatcher.models.RsiRequest
import tickcatcher.models.SmaRequest
import tickcatcher.models.Stoch200ResponseInner
import tickcatcher.models.StochRequest
import tickcatcher.models.Supertrend200ResponseInner
import tickcatcher.models.SupertrendRequest
import tickcatcher.models.VolumemaRequest
import tickcatcher.models.VwapRequest
import tickcatcher.models.WilliamsrRequest
import tickcatcher.models.ZigzagRequest

import com.squareup.moshi.Json

import tickcatcher.infrastructure.ApiClient
import tickcatcher.infrastructure.ApiResponse
import tickcatcher.infrastructure.ClientException
import tickcatcher.infrastructure.ClientError
import tickcatcher.infrastructure.ServerException
import tickcatcher.infrastructure.ServerError
import tickcatcher.infrastructure.MultiValueMap
import tickcatcher.infrastructure.PartConfig
import tickcatcher.infrastructure.RequestConfig
import tickcatcher.infrastructure.RequestMethod
import tickcatcher.infrastructure.ResponseType
import tickcatcher.infrastructure.Success
import tickcatcher.infrastructure.toMultiValue

class IndicatorsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.tickcatcher.com")
        }
    }

    /**
     * POST /api/indicators/adx
     * Calculate Average Directional Index (ADX)
     * 
     * @param adxRequest 
     * @return kotlin.collections.List<Adx200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adx(adxRequest: AdxRequest) : kotlin.collections.List<Adx200ResponseInner> {
        val localVarResponse = adxWithHttpInfo(adxRequest = adxRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Adx200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/adx
     * Calculate Average Directional Index (ADX)
     * 
     * @param adxRequest 
     * @return ApiResponse<kotlin.collections.List<Adx200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adxWithHttpInfo(adxRequest: AdxRequest) : ApiResponse<kotlin.collections.List<Adx200ResponseInner>?> {
        val localVariableConfig = adxRequestConfig(adxRequest = adxRequest)

        return request<AdxRequest, kotlin.collections.List<Adx200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adx
     *
     * @param adxRequest 
     * @return RequestConfig
     */
    fun adxRequestConfig(adxRequest: AdxRequest) : RequestConfig<AdxRequest> {
        val localVariableBody = adxRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/adx",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/atr
     * Calculate Average True Range (ATR)
     * 
     * @param atrRequest 
     * @return kotlin.collections.List<java.math.BigDecimal>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun atr(atrRequest: AtrRequest) : kotlin.collections.List<java.math.BigDecimal> {
        val localVarResponse = atrWithHttpInfo(atrRequest = atrRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/atr
     * Calculate Average True Range (ATR)
     * 
     * @param atrRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun atrWithHttpInfo(atrRequest: AtrRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal>?> {
        val localVariableConfig = atrRequestConfig(atrRequest = atrRequest)

        return request<AtrRequest, kotlin.collections.List<java.math.BigDecimal>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation atr
     *
     * @param atrRequest 
     * @return RequestConfig
     */
    fun atrRequestConfig(atrRequest: AtrRequest) : RequestConfig<AtrRequest> {
        val localVariableBody = atrRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/atr",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/bbands
     * Calculate Bollinger Bands
     * Returns Upper, Middle, and Lower bands.
     * @param bbandsRequest 
     * @return kotlin.collections.List<Bbands200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun bbands(bbandsRequest: BbandsRequest) : kotlin.collections.List<Bbands200ResponseInner> {
        val localVarResponse = bbandsWithHttpInfo(bbandsRequest = bbandsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Bbands200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/bbands
     * Calculate Bollinger Bands
     * Returns Upper, Middle, and Lower bands.
     * @param bbandsRequest 
     * @return ApiResponse<kotlin.collections.List<Bbands200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun bbandsWithHttpInfo(bbandsRequest: BbandsRequest) : ApiResponse<kotlin.collections.List<Bbands200ResponseInner>?> {
        val localVariableConfig = bbandsRequestConfig(bbandsRequest = bbandsRequest)

        return request<BbandsRequest, kotlin.collections.List<Bbands200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation bbands
     *
     * @param bbandsRequest 
     * @return RequestConfig
     */
    fun bbandsRequestConfig(bbandsRequest: BbandsRequest) : RequestConfig<BbandsRequest> {
        val localVariableBody = bbandsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/bbands",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/cci
     * Calculate Commodity Channel Index (CCI)
     * 
     * @param cciRequest 
     * @return kotlin.collections.List<java.math.BigDecimal>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cci(cciRequest: CciRequest) : kotlin.collections.List<java.math.BigDecimal> {
        val localVarResponse = cciWithHttpInfo(cciRequest = cciRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/cci
     * Calculate Commodity Channel Index (CCI)
     * 
     * @param cciRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cciWithHttpInfo(cciRequest: CciRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal>?> {
        val localVariableConfig = cciRequestConfig(cciRequest = cciRequest)

        return request<CciRequest, kotlin.collections.List<java.math.BigDecimal>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cci
     *
     * @param cciRequest 
     * @return RequestConfig
     */
    fun cciRequestConfig(cciRequest: CciRequest) : RequestConfig<CciRequest> {
        val localVariableBody = cciRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/cci",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/ema
     * Calculate Exponential Moving Average (EMA)
     * Returns the EMA of the close prices.
     * @param emaRequest 
     * @return kotlin.collections.List<java.math.BigDecimal>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ema(emaRequest: EmaRequest) : kotlin.collections.List<java.math.BigDecimal> {
        val localVarResponse = emaWithHttpInfo(emaRequest = emaRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/ema
     * Calculate Exponential Moving Average (EMA)
     * Returns the EMA of the close prices.
     * @param emaRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun emaWithHttpInfo(emaRequest: EmaRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal>?> {
        val localVariableConfig = emaRequestConfig(emaRequest = emaRequest)

        return request<EmaRequest, kotlin.collections.List<java.math.BigDecimal>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ema
     *
     * @param emaRequest 
     * @return RequestConfig
     */
    fun emaRequestConfig(emaRequest: EmaRequest) : RequestConfig<EmaRequest> {
        val localVariableBody = emaRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/ema",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/heikenashi
     * Calculate Heiken Ashi
     * 
     * @param heikenashiRequest 
     * @return kotlin.collections.List<Candle>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun heikenashi(heikenashiRequest: HeikenashiRequest) : kotlin.collections.List<Candle> {
        val localVarResponse = heikenashiWithHttpInfo(heikenashiRequest = heikenashiRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Candle>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/heikenashi
     * Calculate Heiken Ashi
     * 
     * @param heikenashiRequest 
     * @return ApiResponse<kotlin.collections.List<Candle>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun heikenashiWithHttpInfo(heikenashiRequest: HeikenashiRequest) : ApiResponse<kotlin.collections.List<Candle>?> {
        val localVariableConfig = heikenashiRequestConfig(heikenashiRequest = heikenashiRequest)

        return request<HeikenashiRequest, kotlin.collections.List<Candle>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation heikenashi
     *
     * @param heikenashiRequest 
     * @return RequestConfig
     */
    fun heikenashiRequestConfig(heikenashiRequest: HeikenashiRequest) : RequestConfig<HeikenashiRequest> {
        val localVariableBody = heikenashiRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/heikenashi",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/ichimoku
     * Calculate Ichimoku Cloud
     * 
     * @param ichimokuRequest 
     * @return kotlin.collections.List<Ichimoku200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ichimoku(ichimokuRequest: IchimokuRequest) : kotlin.collections.List<Ichimoku200ResponseInner> {
        val localVarResponse = ichimokuWithHttpInfo(ichimokuRequest = ichimokuRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Ichimoku200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/ichimoku
     * Calculate Ichimoku Cloud
     * 
     * @param ichimokuRequest 
     * @return ApiResponse<kotlin.collections.List<Ichimoku200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ichimokuWithHttpInfo(ichimokuRequest: IchimokuRequest) : ApiResponse<kotlin.collections.List<Ichimoku200ResponseInner>?> {
        val localVariableConfig = ichimokuRequestConfig(ichimokuRequest = ichimokuRequest)

        return request<IchimokuRequest, kotlin.collections.List<Ichimoku200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ichimoku
     *
     * @param ichimokuRequest 
     * @return RequestConfig
     */
    fun ichimokuRequestConfig(ichimokuRequest: IchimokuRequest) : RequestConfig<IchimokuRequest> {
        val localVariableBody = ichimokuRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/ichimoku",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/keltner
     * Calculate Keltner Channels
     * 
     * @param keltnerRequest 
     * @return kotlin.collections.List<Bbands200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun keltner(keltnerRequest: KeltnerRequest) : kotlin.collections.List<Bbands200ResponseInner> {
        val localVarResponse = keltnerWithHttpInfo(keltnerRequest = keltnerRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Bbands200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/keltner
     * Calculate Keltner Channels
     * 
     * @param keltnerRequest 
     * @return ApiResponse<kotlin.collections.List<Bbands200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun keltnerWithHttpInfo(keltnerRequest: KeltnerRequest) : ApiResponse<kotlin.collections.List<Bbands200ResponseInner>?> {
        val localVariableConfig = keltnerRequestConfig(keltnerRequest = keltnerRequest)

        return request<KeltnerRequest, kotlin.collections.List<Bbands200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation keltner
     *
     * @param keltnerRequest 
     * @return RequestConfig
     */
    fun keltnerRequestConfig(keltnerRequest: KeltnerRequest) : RequestConfig<KeltnerRequest> {
        val localVariableBody = keltnerRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/keltner",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/macd
     * Calculate MACD
     * Returns MACD, Signal, and Histogram.
     * @param macdRequest 
     * @return kotlin.collections.List<Macd200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun macd(macdRequest: MacdRequest) : kotlin.collections.List<Macd200ResponseInner> {
        val localVarResponse = macdWithHttpInfo(macdRequest = macdRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Macd200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/macd
     * Calculate MACD
     * Returns MACD, Signal, and Histogram.
     * @param macdRequest 
     * @return ApiResponse<kotlin.collections.List<Macd200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun macdWithHttpInfo(macdRequest: MacdRequest) : ApiResponse<kotlin.collections.List<Macd200ResponseInner>?> {
        val localVariableConfig = macdRequestConfig(macdRequest = macdRequest)

        return request<MacdRequest, kotlin.collections.List<Macd200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation macd
     *
     * @param macdRequest 
     * @return RequestConfig
     */
    fun macdRequestConfig(macdRequest: MacdRequest) : RequestConfig<MacdRequest> {
        val localVariableBody = macdRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/macd",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/pivot
     * Calculate Pivot Points
     * 
     * @param pivotRequest 
     * @return kotlin.collections.List<Pivot200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun pivot(pivotRequest: PivotRequest) : kotlin.collections.List<Pivot200ResponseInner> {
        val localVarResponse = pivotWithHttpInfo(pivotRequest = pivotRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Pivot200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/pivot
     * Calculate Pivot Points
     * 
     * @param pivotRequest 
     * @return ApiResponse<kotlin.collections.List<Pivot200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun pivotWithHttpInfo(pivotRequest: PivotRequest) : ApiResponse<kotlin.collections.List<Pivot200ResponseInner>?> {
        val localVariableConfig = pivotRequestConfig(pivotRequest = pivotRequest)

        return request<PivotRequest, kotlin.collections.List<Pivot200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pivot
     *
     * @param pivotRequest 
     * @return RequestConfig
     */
    fun pivotRequestConfig(pivotRequest: PivotRequest) : RequestConfig<PivotRequest> {
        val localVariableBody = pivotRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/pivot",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/psar
     * Calculate Parabolic SAR
     * 
     * @param psarRequest 
     * @return kotlin.collections.List<java.math.BigDecimal>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun psar(psarRequest: PsarRequest) : kotlin.collections.List<java.math.BigDecimal> {
        val localVarResponse = psarWithHttpInfo(psarRequest = psarRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/psar
     * Calculate Parabolic SAR
     * 
     * @param psarRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun psarWithHttpInfo(psarRequest: PsarRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal>?> {
        val localVariableConfig = psarRequestConfig(psarRequest = psarRequest)

        return request<PsarRequest, kotlin.collections.List<java.math.BigDecimal>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation psar
     *
     * @param psarRequest 
     * @return RequestConfig
     */
    fun psarRequestConfig(psarRequest: PsarRequest) : RequestConfig<PsarRequest> {
        val localVariableBody = psarRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/psar",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/rsi
     * Calculate Relative Strength Index (RSI)
     * Returns the RSI of the close prices.
     * @param rsiRequest 
     * @return kotlin.collections.List<java.math.BigDecimal>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rsi(rsiRequest: RsiRequest) : kotlin.collections.List<java.math.BigDecimal> {
        val localVarResponse = rsiWithHttpInfo(rsiRequest = rsiRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/rsi
     * Calculate Relative Strength Index (RSI)
     * Returns the RSI of the close prices.
     * @param rsiRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rsiWithHttpInfo(rsiRequest: RsiRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal>?> {
        val localVariableConfig = rsiRequestConfig(rsiRequest = rsiRequest)

        return request<RsiRequest, kotlin.collections.List<java.math.BigDecimal>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rsi
     *
     * @param rsiRequest 
     * @return RequestConfig
     */
    fun rsiRequestConfig(rsiRequest: RsiRequest) : RequestConfig<RsiRequest> {
        val localVariableBody = rsiRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/rsi",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/sma
     * Calculate Simple Moving Average (SMA)
     * Returns the SMA of the close prices.
     * @param smaRequest 
     * @return kotlin.collections.List<java.math.BigDecimal>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sma(smaRequest: SmaRequest) : kotlin.collections.List<java.math.BigDecimal> {
        val localVarResponse = smaWithHttpInfo(smaRequest = smaRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/sma
     * Calculate Simple Moving Average (SMA)
     * Returns the SMA of the close prices.
     * @param smaRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun smaWithHttpInfo(smaRequest: SmaRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal>?> {
        val localVariableConfig = smaRequestConfig(smaRequest = smaRequest)

        return request<SmaRequest, kotlin.collections.List<java.math.BigDecimal>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sma
     *
     * @param smaRequest 
     * @return RequestConfig
     */
    fun smaRequestConfig(smaRequest: SmaRequest) : RequestConfig<SmaRequest> {
        val localVariableBody = smaRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/sma",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/stoch
     * Calculate Stochastic Oscillator
     * Returns %K and %D lines.
     * @param stochRequest 
     * @return kotlin.collections.List<Stoch200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stoch(stochRequest: StochRequest) : kotlin.collections.List<Stoch200ResponseInner> {
        val localVarResponse = stochWithHttpInfo(stochRequest = stochRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Stoch200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/stoch
     * Calculate Stochastic Oscillator
     * Returns %K and %D lines.
     * @param stochRequest 
     * @return ApiResponse<kotlin.collections.List<Stoch200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stochWithHttpInfo(stochRequest: StochRequest) : ApiResponse<kotlin.collections.List<Stoch200ResponseInner>?> {
        val localVariableConfig = stochRequestConfig(stochRequest = stochRequest)

        return request<StochRequest, kotlin.collections.List<Stoch200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stoch
     *
     * @param stochRequest 
     * @return RequestConfig
     */
    fun stochRequestConfig(stochRequest: StochRequest) : RequestConfig<StochRequest> {
        val localVariableBody = stochRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/stoch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/supertrend
     * Calculate SuperTrend
     * 
     * @param supertrendRequest 
     * @return kotlin.collections.List<Supertrend200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun supertrend(supertrendRequest: SupertrendRequest) : kotlin.collections.List<Supertrend200ResponseInner> {
        val localVarResponse = supertrendWithHttpInfo(supertrendRequest = supertrendRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Supertrend200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/supertrend
     * Calculate SuperTrend
     * 
     * @param supertrendRequest 
     * @return ApiResponse<kotlin.collections.List<Supertrend200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun supertrendWithHttpInfo(supertrendRequest: SupertrendRequest) : ApiResponse<kotlin.collections.List<Supertrend200ResponseInner>?> {
        val localVariableConfig = supertrendRequestConfig(supertrendRequest = supertrendRequest)

        return request<SupertrendRequest, kotlin.collections.List<Supertrend200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation supertrend
     *
     * @param supertrendRequest 
     * @return RequestConfig
     */
    fun supertrendRequestConfig(supertrendRequest: SupertrendRequest) : RequestConfig<SupertrendRequest> {
        val localVariableBody = supertrendRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/supertrend",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/volumema
     * Calculate Volume MA
     * Returns Simple Moving Average of Volume.
     * @param volumemaRequest 
     * @return kotlin.collections.List<java.math.BigDecimal>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun volumema(volumemaRequest: VolumemaRequest) : kotlin.collections.List<java.math.BigDecimal> {
        val localVarResponse = volumemaWithHttpInfo(volumemaRequest = volumemaRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/volumema
     * Calculate Volume MA
     * Returns Simple Moving Average of Volume.
     * @param volumemaRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun volumemaWithHttpInfo(volumemaRequest: VolumemaRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal>?> {
        val localVariableConfig = volumemaRequestConfig(volumemaRequest = volumemaRequest)

        return request<VolumemaRequest, kotlin.collections.List<java.math.BigDecimal>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation volumema
     *
     * @param volumemaRequest 
     * @return RequestConfig
     */
    fun volumemaRequestConfig(volumemaRequest: VolumemaRequest) : RequestConfig<VolumemaRequest> {
        val localVariableBody = volumemaRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/volumema",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/vwap
     * Calculate VWAP
     * 
     * @param vwapRequest 
     * @return kotlin.collections.List<java.math.BigDecimal>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun vwap(vwapRequest: VwapRequest) : kotlin.collections.List<java.math.BigDecimal> {
        val localVarResponse = vwapWithHttpInfo(vwapRequest = vwapRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/vwap
     * Calculate VWAP
     * 
     * @param vwapRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun vwapWithHttpInfo(vwapRequest: VwapRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal>?> {
        val localVariableConfig = vwapRequestConfig(vwapRequest = vwapRequest)

        return request<VwapRequest, kotlin.collections.List<java.math.BigDecimal>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation vwap
     *
     * @param vwapRequest 
     * @return RequestConfig
     */
    fun vwapRequestConfig(vwapRequest: VwapRequest) : RequestConfig<VwapRequest> {
        val localVariableBody = vwapRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/vwap",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/williamsr
     * Calculate Williams %R
     * 
     * @param williamsrRequest 
     * @return kotlin.collections.List<java.math.BigDecimal>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun williamsr(williamsrRequest: WilliamsrRequest) : kotlin.collections.List<java.math.BigDecimal> {
        val localVarResponse = williamsrWithHttpInfo(williamsrRequest = williamsrRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/williamsr
     * Calculate Williams %R
     * 
     * @param williamsrRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun williamsrWithHttpInfo(williamsrRequest: WilliamsrRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal>?> {
        val localVariableConfig = williamsrRequestConfig(williamsrRequest = williamsrRequest)

        return request<WilliamsrRequest, kotlin.collections.List<java.math.BigDecimal>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation williamsr
     *
     * @param williamsrRequest 
     * @return RequestConfig
     */
    fun williamsrRequestConfig(williamsrRequest: WilliamsrRequest) : RequestConfig<WilliamsrRequest> {
        val localVariableBody = williamsrRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/williamsr",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/indicators/zigzag
     * Calculate ZigZag Indicator
     * 
     * @param zigzagRequest 
     * @return kotlin.collections.List<java.math.BigDecimal?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun zigzag(zigzagRequest: ZigzagRequest) : kotlin.collections.List<java.math.BigDecimal?> {
        val localVarResponse = zigzagWithHttpInfo(zigzagRequest = zigzagRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.math.BigDecimal?>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/indicators/zigzag
     * Calculate ZigZag Indicator
     * 
     * @param zigzagRequest 
     * @return ApiResponse<kotlin.collections.List<java.math.BigDecimal?>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun zigzagWithHttpInfo(zigzagRequest: ZigzagRequest) : ApiResponse<kotlin.collections.List<java.math.BigDecimal?>?> {
        val localVariableConfig = zigzagRequestConfig(zigzagRequest = zigzagRequest)

        return request<ZigzagRequest, kotlin.collections.List<java.math.BigDecimal?>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation zigzag
     *
     * @param zigzagRequest 
     * @return RequestConfig
     */
    fun zigzagRequestConfig(zigzagRequest: ZigzagRequest) : RequestConfig<ZigzagRequest> {
        val localVariableBody = zigzagRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/indicators/zigzag",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
