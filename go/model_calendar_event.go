/*
Tickcatcher API

The Tickcatcher API provides access to cryptocurrency market data including candlesticks, symbols, and indicators. All requests require authentication using your RapidAPI key. 

API version: 1.1.1
Contact: yagiz@iskirik.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tickcatcher

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the CalendarEvent type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &CalendarEvent{}

// CalendarEvent struct for CalendarEvent
type CalendarEvent struct {
	Title string `json:"title"`
	Country string `json:"country"`
	Indicator NullableString `json:"indicator,omitempty"`
	Ticker NullableString `json:"ticker,omitempty"`
	Comment NullableString `json:"comment,omitempty"`
	Category NullableString `json:"category,omitempty"`
	Period NullableString `json:"period,omitempty"`
	ReferenceDate NullableString `json:"reference_date,omitempty"`
	Source NullableString `json:"source,omitempty"`
	SourceUrl NullableString `json:"source_url,omitempty"`
	Actual NullableFloat32 `json:"actual,omitempty"`
	Previous NullableFloat32 `json:"previous,omitempty"`
	Forecast NullableFloat32 `json:"forecast,omitempty"`
	ActualRaw NullableFloat32 `json:"actual_raw,omitempty"`
	PreviousRaw NullableFloat32 `json:"previous_raw,omitempty"`
	ForecastRaw NullableFloat32 `json:"forecast_raw,omitempty"`
	Currency NullableString `json:"currency,omitempty"`
	Unit NullableString `json:"unit,omitempty"`
	// A number of importance, can be -1, 0 or 1.
	Importance float32 `json:"importance"`
	// Unix timestamp (ms)
	Ts float32 `json:"ts"`
	Scale NullableString `json:"scale,omitempty"`
}

type _CalendarEvent CalendarEvent

// NewCalendarEvent instantiates a new CalendarEvent object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewCalendarEvent(title string, country string, importance float32, ts float32) *CalendarEvent {
	this := CalendarEvent{}
	this.Title = title
	this.Country = country
	this.Importance = importance
	this.Ts = ts
	return &this
}

// NewCalendarEventWithDefaults instantiates a new CalendarEvent object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewCalendarEventWithDefaults() *CalendarEvent {
	this := CalendarEvent{}
	return &this
}

// GetTitle returns the Title field value
func (o *CalendarEvent) GetTitle() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Title
}

// GetTitleOk returns a tuple with the Title field value
// and a boolean to check if the value has been set.
func (o *CalendarEvent) GetTitleOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Title, true
}

// SetTitle sets field value
func (o *CalendarEvent) SetTitle(v string) {
	o.Title = v
}

// GetCountry returns the Country field value
func (o *CalendarEvent) GetCountry() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Country
}

// GetCountryOk returns a tuple with the Country field value
// and a boolean to check if the value has been set.
func (o *CalendarEvent) GetCountryOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Country, true
}

// SetCountry sets field value
func (o *CalendarEvent) SetCountry(v string) {
	o.Country = v
}

// GetIndicator returns the Indicator field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetIndicator() string {
	if o == nil || IsNil(o.Indicator.Get()) {
		var ret string
		return ret
	}
	return *o.Indicator.Get()
}

// GetIndicatorOk returns a tuple with the Indicator field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetIndicatorOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Indicator.Get(), o.Indicator.IsSet()
}

// HasIndicator returns a boolean if a field has been set.
func (o *CalendarEvent) HasIndicator() bool {
	if o != nil && o.Indicator.IsSet() {
		return true
	}

	return false
}

// SetIndicator gets a reference to the given NullableString and assigns it to the Indicator field.
func (o *CalendarEvent) SetIndicator(v string) {
	o.Indicator.Set(&v)
}
// SetIndicatorNil sets the value for Indicator to be an explicit nil
func (o *CalendarEvent) SetIndicatorNil() {
	o.Indicator.Set(nil)
}

// UnsetIndicator ensures that no value is present for Indicator, not even an explicit nil
func (o *CalendarEvent) UnsetIndicator() {
	o.Indicator.Unset()
}

// GetTicker returns the Ticker field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetTicker() string {
	if o == nil || IsNil(o.Ticker.Get()) {
		var ret string
		return ret
	}
	return *o.Ticker.Get()
}

// GetTickerOk returns a tuple with the Ticker field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetTickerOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Ticker.Get(), o.Ticker.IsSet()
}

// HasTicker returns a boolean if a field has been set.
func (o *CalendarEvent) HasTicker() bool {
	if o != nil && o.Ticker.IsSet() {
		return true
	}

	return false
}

// SetTicker gets a reference to the given NullableString and assigns it to the Ticker field.
func (o *CalendarEvent) SetTicker(v string) {
	o.Ticker.Set(&v)
}
// SetTickerNil sets the value for Ticker to be an explicit nil
func (o *CalendarEvent) SetTickerNil() {
	o.Ticker.Set(nil)
}

// UnsetTicker ensures that no value is present for Ticker, not even an explicit nil
func (o *CalendarEvent) UnsetTicker() {
	o.Ticker.Unset()
}

// GetComment returns the Comment field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetComment() string {
	if o == nil || IsNil(o.Comment.Get()) {
		var ret string
		return ret
	}
	return *o.Comment.Get()
}

// GetCommentOk returns a tuple with the Comment field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetCommentOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Comment.Get(), o.Comment.IsSet()
}

// HasComment returns a boolean if a field has been set.
func (o *CalendarEvent) HasComment() bool {
	if o != nil && o.Comment.IsSet() {
		return true
	}

	return false
}

// SetComment gets a reference to the given NullableString and assigns it to the Comment field.
func (o *CalendarEvent) SetComment(v string) {
	o.Comment.Set(&v)
}
// SetCommentNil sets the value for Comment to be an explicit nil
func (o *CalendarEvent) SetCommentNil() {
	o.Comment.Set(nil)
}

// UnsetComment ensures that no value is present for Comment, not even an explicit nil
func (o *CalendarEvent) UnsetComment() {
	o.Comment.Unset()
}

// GetCategory returns the Category field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetCategory() string {
	if o == nil || IsNil(o.Category.Get()) {
		var ret string
		return ret
	}
	return *o.Category.Get()
}

// GetCategoryOk returns a tuple with the Category field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetCategoryOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Category.Get(), o.Category.IsSet()
}

// HasCategory returns a boolean if a field has been set.
func (o *CalendarEvent) HasCategory() bool {
	if o != nil && o.Category.IsSet() {
		return true
	}

	return false
}

// SetCategory gets a reference to the given NullableString and assigns it to the Category field.
func (o *CalendarEvent) SetCategory(v string) {
	o.Category.Set(&v)
}
// SetCategoryNil sets the value for Category to be an explicit nil
func (o *CalendarEvent) SetCategoryNil() {
	o.Category.Set(nil)
}

// UnsetCategory ensures that no value is present for Category, not even an explicit nil
func (o *CalendarEvent) UnsetCategory() {
	o.Category.Unset()
}

// GetPeriod returns the Period field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetPeriod() string {
	if o == nil || IsNil(o.Period.Get()) {
		var ret string
		return ret
	}
	return *o.Period.Get()
}

// GetPeriodOk returns a tuple with the Period field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetPeriodOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Period.Get(), o.Period.IsSet()
}

// HasPeriod returns a boolean if a field has been set.
func (o *CalendarEvent) HasPeriod() bool {
	if o != nil && o.Period.IsSet() {
		return true
	}

	return false
}

// SetPeriod gets a reference to the given NullableString and assigns it to the Period field.
func (o *CalendarEvent) SetPeriod(v string) {
	o.Period.Set(&v)
}
// SetPeriodNil sets the value for Period to be an explicit nil
func (o *CalendarEvent) SetPeriodNil() {
	o.Period.Set(nil)
}

// UnsetPeriod ensures that no value is present for Period, not even an explicit nil
func (o *CalendarEvent) UnsetPeriod() {
	o.Period.Unset()
}

// GetReferenceDate returns the ReferenceDate field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetReferenceDate() string {
	if o == nil || IsNil(o.ReferenceDate.Get()) {
		var ret string
		return ret
	}
	return *o.ReferenceDate.Get()
}

// GetReferenceDateOk returns a tuple with the ReferenceDate field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetReferenceDateOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.ReferenceDate.Get(), o.ReferenceDate.IsSet()
}

// HasReferenceDate returns a boolean if a field has been set.
func (o *CalendarEvent) HasReferenceDate() bool {
	if o != nil && o.ReferenceDate.IsSet() {
		return true
	}

	return false
}

// SetReferenceDate gets a reference to the given NullableString and assigns it to the ReferenceDate field.
func (o *CalendarEvent) SetReferenceDate(v string) {
	o.ReferenceDate.Set(&v)
}
// SetReferenceDateNil sets the value for ReferenceDate to be an explicit nil
func (o *CalendarEvent) SetReferenceDateNil() {
	o.ReferenceDate.Set(nil)
}

// UnsetReferenceDate ensures that no value is present for ReferenceDate, not even an explicit nil
func (o *CalendarEvent) UnsetReferenceDate() {
	o.ReferenceDate.Unset()
}

// GetSource returns the Source field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetSource() string {
	if o == nil || IsNil(o.Source.Get()) {
		var ret string
		return ret
	}
	return *o.Source.Get()
}

// GetSourceOk returns a tuple with the Source field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetSourceOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Source.Get(), o.Source.IsSet()
}

// HasSource returns a boolean if a field has been set.
func (o *CalendarEvent) HasSource() bool {
	if o != nil && o.Source.IsSet() {
		return true
	}

	return false
}

// SetSource gets a reference to the given NullableString and assigns it to the Source field.
func (o *CalendarEvent) SetSource(v string) {
	o.Source.Set(&v)
}
// SetSourceNil sets the value for Source to be an explicit nil
func (o *CalendarEvent) SetSourceNil() {
	o.Source.Set(nil)
}

// UnsetSource ensures that no value is present for Source, not even an explicit nil
func (o *CalendarEvent) UnsetSource() {
	o.Source.Unset()
}

// GetSourceUrl returns the SourceUrl field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetSourceUrl() string {
	if o == nil || IsNil(o.SourceUrl.Get()) {
		var ret string
		return ret
	}
	return *o.SourceUrl.Get()
}

// GetSourceUrlOk returns a tuple with the SourceUrl field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetSourceUrlOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.SourceUrl.Get(), o.SourceUrl.IsSet()
}

// HasSourceUrl returns a boolean if a field has been set.
func (o *CalendarEvent) HasSourceUrl() bool {
	if o != nil && o.SourceUrl.IsSet() {
		return true
	}

	return false
}

// SetSourceUrl gets a reference to the given NullableString and assigns it to the SourceUrl field.
func (o *CalendarEvent) SetSourceUrl(v string) {
	o.SourceUrl.Set(&v)
}
// SetSourceUrlNil sets the value for SourceUrl to be an explicit nil
func (o *CalendarEvent) SetSourceUrlNil() {
	o.SourceUrl.Set(nil)
}

// UnsetSourceUrl ensures that no value is present for SourceUrl, not even an explicit nil
func (o *CalendarEvent) UnsetSourceUrl() {
	o.SourceUrl.Unset()
}

// GetActual returns the Actual field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetActual() float32 {
	if o == nil || IsNil(o.Actual.Get()) {
		var ret float32
		return ret
	}
	return *o.Actual.Get()
}

// GetActualOk returns a tuple with the Actual field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetActualOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return o.Actual.Get(), o.Actual.IsSet()
}

// HasActual returns a boolean if a field has been set.
func (o *CalendarEvent) HasActual() bool {
	if o != nil && o.Actual.IsSet() {
		return true
	}

	return false
}

// SetActual gets a reference to the given NullableFloat32 and assigns it to the Actual field.
func (o *CalendarEvent) SetActual(v float32) {
	o.Actual.Set(&v)
}
// SetActualNil sets the value for Actual to be an explicit nil
func (o *CalendarEvent) SetActualNil() {
	o.Actual.Set(nil)
}

// UnsetActual ensures that no value is present for Actual, not even an explicit nil
func (o *CalendarEvent) UnsetActual() {
	o.Actual.Unset()
}

// GetPrevious returns the Previous field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetPrevious() float32 {
	if o == nil || IsNil(o.Previous.Get()) {
		var ret float32
		return ret
	}
	return *o.Previous.Get()
}

// GetPreviousOk returns a tuple with the Previous field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetPreviousOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return o.Previous.Get(), o.Previous.IsSet()
}

// HasPrevious returns a boolean if a field has been set.
func (o *CalendarEvent) HasPrevious() bool {
	if o != nil && o.Previous.IsSet() {
		return true
	}

	return false
}

// SetPrevious gets a reference to the given NullableFloat32 and assigns it to the Previous field.
func (o *CalendarEvent) SetPrevious(v float32) {
	o.Previous.Set(&v)
}
// SetPreviousNil sets the value for Previous to be an explicit nil
func (o *CalendarEvent) SetPreviousNil() {
	o.Previous.Set(nil)
}

// UnsetPrevious ensures that no value is present for Previous, not even an explicit nil
func (o *CalendarEvent) UnsetPrevious() {
	o.Previous.Unset()
}

// GetForecast returns the Forecast field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetForecast() float32 {
	if o == nil || IsNil(o.Forecast.Get()) {
		var ret float32
		return ret
	}
	return *o.Forecast.Get()
}

// GetForecastOk returns a tuple with the Forecast field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetForecastOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return o.Forecast.Get(), o.Forecast.IsSet()
}

// HasForecast returns a boolean if a field has been set.
func (o *CalendarEvent) HasForecast() bool {
	if o != nil && o.Forecast.IsSet() {
		return true
	}

	return false
}

// SetForecast gets a reference to the given NullableFloat32 and assigns it to the Forecast field.
func (o *CalendarEvent) SetForecast(v float32) {
	o.Forecast.Set(&v)
}
// SetForecastNil sets the value for Forecast to be an explicit nil
func (o *CalendarEvent) SetForecastNil() {
	o.Forecast.Set(nil)
}

// UnsetForecast ensures that no value is present for Forecast, not even an explicit nil
func (o *CalendarEvent) UnsetForecast() {
	o.Forecast.Unset()
}

// GetActualRaw returns the ActualRaw field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetActualRaw() float32 {
	if o == nil || IsNil(o.ActualRaw.Get()) {
		var ret float32
		return ret
	}
	return *o.ActualRaw.Get()
}

// GetActualRawOk returns a tuple with the ActualRaw field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetActualRawOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return o.ActualRaw.Get(), o.ActualRaw.IsSet()
}

// HasActualRaw returns a boolean if a field has been set.
func (o *CalendarEvent) HasActualRaw() bool {
	if o != nil && o.ActualRaw.IsSet() {
		return true
	}

	return false
}

// SetActualRaw gets a reference to the given NullableFloat32 and assigns it to the ActualRaw field.
func (o *CalendarEvent) SetActualRaw(v float32) {
	o.ActualRaw.Set(&v)
}
// SetActualRawNil sets the value for ActualRaw to be an explicit nil
func (o *CalendarEvent) SetActualRawNil() {
	o.ActualRaw.Set(nil)
}

// UnsetActualRaw ensures that no value is present for ActualRaw, not even an explicit nil
func (o *CalendarEvent) UnsetActualRaw() {
	o.ActualRaw.Unset()
}

// GetPreviousRaw returns the PreviousRaw field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetPreviousRaw() float32 {
	if o == nil || IsNil(o.PreviousRaw.Get()) {
		var ret float32
		return ret
	}
	return *o.PreviousRaw.Get()
}

// GetPreviousRawOk returns a tuple with the PreviousRaw field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetPreviousRawOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return o.PreviousRaw.Get(), o.PreviousRaw.IsSet()
}

// HasPreviousRaw returns a boolean if a field has been set.
func (o *CalendarEvent) HasPreviousRaw() bool {
	if o != nil && o.PreviousRaw.IsSet() {
		return true
	}

	return false
}

// SetPreviousRaw gets a reference to the given NullableFloat32 and assigns it to the PreviousRaw field.
func (o *CalendarEvent) SetPreviousRaw(v float32) {
	o.PreviousRaw.Set(&v)
}
// SetPreviousRawNil sets the value for PreviousRaw to be an explicit nil
func (o *CalendarEvent) SetPreviousRawNil() {
	o.PreviousRaw.Set(nil)
}

// UnsetPreviousRaw ensures that no value is present for PreviousRaw, not even an explicit nil
func (o *CalendarEvent) UnsetPreviousRaw() {
	o.PreviousRaw.Unset()
}

// GetForecastRaw returns the ForecastRaw field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetForecastRaw() float32 {
	if o == nil || IsNil(o.ForecastRaw.Get()) {
		var ret float32
		return ret
	}
	return *o.ForecastRaw.Get()
}

// GetForecastRawOk returns a tuple with the ForecastRaw field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetForecastRawOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return o.ForecastRaw.Get(), o.ForecastRaw.IsSet()
}

// HasForecastRaw returns a boolean if a field has been set.
func (o *CalendarEvent) HasForecastRaw() bool {
	if o != nil && o.ForecastRaw.IsSet() {
		return true
	}

	return false
}

// SetForecastRaw gets a reference to the given NullableFloat32 and assigns it to the ForecastRaw field.
func (o *CalendarEvent) SetForecastRaw(v float32) {
	o.ForecastRaw.Set(&v)
}
// SetForecastRawNil sets the value for ForecastRaw to be an explicit nil
func (o *CalendarEvent) SetForecastRawNil() {
	o.ForecastRaw.Set(nil)
}

// UnsetForecastRaw ensures that no value is present for ForecastRaw, not even an explicit nil
func (o *CalendarEvent) UnsetForecastRaw() {
	o.ForecastRaw.Unset()
}

// GetCurrency returns the Currency field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetCurrency() string {
	if o == nil || IsNil(o.Currency.Get()) {
		var ret string
		return ret
	}
	return *o.Currency.Get()
}

// GetCurrencyOk returns a tuple with the Currency field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetCurrencyOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Currency.Get(), o.Currency.IsSet()
}

// HasCurrency returns a boolean if a field has been set.
func (o *CalendarEvent) HasCurrency() bool {
	if o != nil && o.Currency.IsSet() {
		return true
	}

	return false
}

// SetCurrency gets a reference to the given NullableString and assigns it to the Currency field.
func (o *CalendarEvent) SetCurrency(v string) {
	o.Currency.Set(&v)
}
// SetCurrencyNil sets the value for Currency to be an explicit nil
func (o *CalendarEvent) SetCurrencyNil() {
	o.Currency.Set(nil)
}

// UnsetCurrency ensures that no value is present for Currency, not even an explicit nil
func (o *CalendarEvent) UnsetCurrency() {
	o.Currency.Unset()
}

// GetUnit returns the Unit field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetUnit() string {
	if o == nil || IsNil(o.Unit.Get()) {
		var ret string
		return ret
	}
	return *o.Unit.Get()
}

// GetUnitOk returns a tuple with the Unit field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetUnitOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Unit.Get(), o.Unit.IsSet()
}

// HasUnit returns a boolean if a field has been set.
func (o *CalendarEvent) HasUnit() bool {
	if o != nil && o.Unit.IsSet() {
		return true
	}

	return false
}

// SetUnit gets a reference to the given NullableString and assigns it to the Unit field.
func (o *CalendarEvent) SetUnit(v string) {
	o.Unit.Set(&v)
}
// SetUnitNil sets the value for Unit to be an explicit nil
func (o *CalendarEvent) SetUnitNil() {
	o.Unit.Set(nil)
}

// UnsetUnit ensures that no value is present for Unit, not even an explicit nil
func (o *CalendarEvent) UnsetUnit() {
	o.Unit.Unset()
}

// GetImportance returns the Importance field value
func (o *CalendarEvent) GetImportance() float32 {
	if o == nil {
		var ret float32
		return ret
	}

	return o.Importance
}

// GetImportanceOk returns a tuple with the Importance field value
// and a boolean to check if the value has been set.
func (o *CalendarEvent) GetImportanceOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Importance, true
}

// SetImportance sets field value
func (o *CalendarEvent) SetImportance(v float32) {
	o.Importance = v
}

// GetTs returns the Ts field value
func (o *CalendarEvent) GetTs() float32 {
	if o == nil {
		var ret float32
		return ret
	}

	return o.Ts
}

// GetTsOk returns a tuple with the Ts field value
// and a boolean to check if the value has been set.
func (o *CalendarEvent) GetTsOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Ts, true
}

// SetTs sets field value
func (o *CalendarEvent) SetTs(v float32) {
	o.Ts = v
}

// GetScale returns the Scale field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CalendarEvent) GetScale() string {
	if o == nil || IsNil(o.Scale.Get()) {
		var ret string
		return ret
	}
	return *o.Scale.Get()
}

// GetScaleOk returns a tuple with the Scale field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CalendarEvent) GetScaleOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Scale.Get(), o.Scale.IsSet()
}

// HasScale returns a boolean if a field has been set.
func (o *CalendarEvent) HasScale() bool {
	if o != nil && o.Scale.IsSet() {
		return true
	}

	return false
}

// SetScale gets a reference to the given NullableString and assigns it to the Scale field.
func (o *CalendarEvent) SetScale(v string) {
	o.Scale.Set(&v)
}
// SetScaleNil sets the value for Scale to be an explicit nil
func (o *CalendarEvent) SetScaleNil() {
	o.Scale.Set(nil)
}

// UnsetScale ensures that no value is present for Scale, not even an explicit nil
func (o *CalendarEvent) UnsetScale() {
	o.Scale.Unset()
}

func (o CalendarEvent) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o CalendarEvent) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["title"] = o.Title
	toSerialize["country"] = o.Country
	if o.Indicator.IsSet() {
		toSerialize["indicator"] = o.Indicator.Get()
	}
	if o.Ticker.IsSet() {
		toSerialize["ticker"] = o.Ticker.Get()
	}
	if o.Comment.IsSet() {
		toSerialize["comment"] = o.Comment.Get()
	}
	if o.Category.IsSet() {
		toSerialize["category"] = o.Category.Get()
	}
	if o.Period.IsSet() {
		toSerialize["period"] = o.Period.Get()
	}
	if o.ReferenceDate.IsSet() {
		toSerialize["reference_date"] = o.ReferenceDate.Get()
	}
	if o.Source.IsSet() {
		toSerialize["source"] = o.Source.Get()
	}
	if o.SourceUrl.IsSet() {
		toSerialize["source_url"] = o.SourceUrl.Get()
	}
	if o.Actual.IsSet() {
		toSerialize["actual"] = o.Actual.Get()
	}
	if o.Previous.IsSet() {
		toSerialize["previous"] = o.Previous.Get()
	}
	if o.Forecast.IsSet() {
		toSerialize["forecast"] = o.Forecast.Get()
	}
	if o.ActualRaw.IsSet() {
		toSerialize["actual_raw"] = o.ActualRaw.Get()
	}
	if o.PreviousRaw.IsSet() {
		toSerialize["previous_raw"] = o.PreviousRaw.Get()
	}
	if o.ForecastRaw.IsSet() {
		toSerialize["forecast_raw"] = o.ForecastRaw.Get()
	}
	if o.Currency.IsSet() {
		toSerialize["currency"] = o.Currency.Get()
	}
	if o.Unit.IsSet() {
		toSerialize["unit"] = o.Unit.Get()
	}
	toSerialize["importance"] = o.Importance
	toSerialize["ts"] = o.Ts
	if o.Scale.IsSet() {
		toSerialize["scale"] = o.Scale.Get()
	}
	return toSerialize, nil
}

func (o *CalendarEvent) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"title",
		"country",
		"importance",
		"ts",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varCalendarEvent := _CalendarEvent{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varCalendarEvent)

	if err != nil {
		return err
	}

	*o = CalendarEvent(varCalendarEvent)

	return err
}

type NullableCalendarEvent struct {
	value *CalendarEvent
	isSet bool
}

func (v NullableCalendarEvent) Get() *CalendarEvent {
	return v.value
}

func (v *NullableCalendarEvent) Set(val *CalendarEvent) {
	v.value = val
	v.isSet = true
}

func (v NullableCalendarEvent) IsSet() bool {
	return v.isSet
}

func (v *NullableCalendarEvent) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCalendarEvent(val *CalendarEvent) *NullableCalendarEvent {
	return &NullableCalendarEvent{value: val, isSet: true}
}

func (v NullableCalendarEvent) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCalendarEvent) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


