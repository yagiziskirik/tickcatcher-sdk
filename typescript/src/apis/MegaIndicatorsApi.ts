/* tslint:disable */
/* eslint-disable */
/**
 * Tickcatcher API
 * The Tickcatcher API provides access to cryptocurrency market data including candlesticks, symbols, and indicators. All requests require authentication using your RapidAPI key. 
 *
 * The version of the OpenAPI document: 1.1.4
 * Contact: yagiz@iskirik.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Candle,
  EmaRequest,
  HeikenashiRequest,
  Ichimoku200ResponseInner,
  IchimokuRequest,
  Supertrend200ResponseInner,
  SupertrendRequest,
} from '../models/index';
import {
    CandleFromJSON,
    CandleToJSON,
    EmaRequestFromJSON,
    EmaRequestToJSON,
    HeikenashiRequestFromJSON,
    HeikenashiRequestToJSON,
    Ichimoku200ResponseInnerFromJSON,
    Ichimoku200ResponseInnerToJSON,
    IchimokuRequestFromJSON,
    IchimokuRequestToJSON,
    Supertrend200ResponseInnerFromJSON,
    Supertrend200ResponseInnerToJSON,
    SupertrendRequestFromJSON,
    SupertrendRequestToJSON,
} from '../models/index';

export interface HeikenashiOperationRequest {
    heikenashiRequest: HeikenashiRequest;
}

export interface IchimokuOperationRequest {
    ichimokuRequest: IchimokuRequest;
}

export interface SupertrendOperationRequest {
    supertrendRequest: SupertrendRequest;
}

export interface WilliamsrRequest {
    emaRequest: EmaRequest;
}

/**
 * 
 */
export class MegaIndicatorsApi extends runtime.BaseAPI {

    /**
     * Calculate Heiken Ashi
     */
    async heikenashiRaw(requestParameters: HeikenashiOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Candle>>> {
        if (requestParameters['heikenashiRequest'] == null) {
            throw new runtime.RequiredError(
                'heikenashiRequest',
                'Required parameter "heikenashiRequest" was null or undefined when calling heikenashi().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/heikenashi`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: HeikenashiRequestToJSON(requestParameters['heikenashiRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CandleFromJSON));
    }

    /**
     * Calculate Heiken Ashi
     */
    async heikenashi(requestParameters: HeikenashiOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Candle>> {
        const response = await this.heikenashiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Ichimoku Cloud
     */
    async ichimokuRaw(requestParameters: IchimokuOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Ichimoku200ResponseInner>>> {
        if (requestParameters['ichimokuRequest'] == null) {
            throw new runtime.RequiredError(
                'ichimokuRequest',
                'Required parameter "ichimokuRequest" was null or undefined when calling ichimoku().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/ichimoku`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IchimokuRequestToJSON(requestParameters['ichimokuRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Ichimoku200ResponseInnerFromJSON));
    }

    /**
     * Calculate Ichimoku Cloud
     */
    async ichimoku(requestParameters: IchimokuOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Ichimoku200ResponseInner>> {
        const response = await this.ichimokuRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate SuperTrend
     */
    async supertrendRaw(requestParameters: SupertrendOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Supertrend200ResponseInner>>> {
        if (requestParameters['supertrendRequest'] == null) {
            throw new runtime.RequiredError(
                'supertrendRequest',
                'Required parameter "supertrendRequest" was null or undefined when calling supertrend().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/supertrend`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SupertrendRequestToJSON(requestParameters['supertrendRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Supertrend200ResponseInnerFromJSON));
    }

    /**
     * Calculate SuperTrend
     */
    async supertrend(requestParameters: SupertrendOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Supertrend200ResponseInner>> {
        const response = await this.supertrendRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Williams %R
     */
    async williamsrRaw(requestParameters: WilliamsrRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['emaRequest'] == null) {
            throw new runtime.RequiredError(
                'emaRequest',
                'Required parameter "emaRequest" was null or undefined when calling williamsr().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/williamsr`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EmaRequestToJSON(requestParameters['emaRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Calculate Williams %R
     */
    async williamsr(requestParameters: WilliamsrRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.williamsrRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
