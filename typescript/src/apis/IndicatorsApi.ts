/* tslint:disable */
/* eslint-disable */
/**
 * Tickcatcher API
 * The Tickcatcher API provides access to cryptocurrency market data including candlesticks, symbols, and indicators. All requests require authentication using your RapidAPI key or TickCatcher Direct Key. 
 *
 * The version of the OpenAPI document: 1.1.7
 * Contact: yagiz@iskirik.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Adx200ResponseInner,
  AdxRequest,
  AtrRequest,
  Bbands200ResponseInner,
  BbandsRequest,
  Candle,
  CciRequest,
  EmaRequest,
  HeikenashiRequest,
  Ichimoku200ResponseInner,
  IchimokuRequest,
  KeltnerRequest,
  Macd200ResponseInner,
  MacdRequest,
  Pivot200ResponseInner,
  PivotRequest,
  PsarRequest,
  RsiRequest,
  SmaRequest,
  Stoch200ResponseInner,
  StochRequest,
  Supertrend200ResponseInner,
  SupertrendRequest,
  VolumemaRequest,
  VwapRequest,
  WilliamsrRequest,
  ZigzagRequest,
} from '../models/index';
import {
    Adx200ResponseInnerFromJSON,
    Adx200ResponseInnerToJSON,
    AdxRequestFromJSON,
    AdxRequestToJSON,
    AtrRequestFromJSON,
    AtrRequestToJSON,
    Bbands200ResponseInnerFromJSON,
    Bbands200ResponseInnerToJSON,
    BbandsRequestFromJSON,
    BbandsRequestToJSON,
    CandleFromJSON,
    CandleToJSON,
    CciRequestFromJSON,
    CciRequestToJSON,
    EmaRequestFromJSON,
    EmaRequestToJSON,
    HeikenashiRequestFromJSON,
    HeikenashiRequestToJSON,
    Ichimoku200ResponseInnerFromJSON,
    Ichimoku200ResponseInnerToJSON,
    IchimokuRequestFromJSON,
    IchimokuRequestToJSON,
    KeltnerRequestFromJSON,
    KeltnerRequestToJSON,
    Macd200ResponseInnerFromJSON,
    Macd200ResponseInnerToJSON,
    MacdRequestFromJSON,
    MacdRequestToJSON,
    Pivot200ResponseInnerFromJSON,
    Pivot200ResponseInnerToJSON,
    PivotRequestFromJSON,
    PivotRequestToJSON,
    PsarRequestFromJSON,
    PsarRequestToJSON,
    RsiRequestFromJSON,
    RsiRequestToJSON,
    SmaRequestFromJSON,
    SmaRequestToJSON,
    Stoch200ResponseInnerFromJSON,
    Stoch200ResponseInnerToJSON,
    StochRequestFromJSON,
    StochRequestToJSON,
    Supertrend200ResponseInnerFromJSON,
    Supertrend200ResponseInnerToJSON,
    SupertrendRequestFromJSON,
    SupertrendRequestToJSON,
    VolumemaRequestFromJSON,
    VolumemaRequestToJSON,
    VwapRequestFromJSON,
    VwapRequestToJSON,
    WilliamsrRequestFromJSON,
    WilliamsrRequestToJSON,
    ZigzagRequestFromJSON,
    ZigzagRequestToJSON,
} from '../models/index';

export interface AdxOperationRequest {
    adxRequest: AdxRequest;
}

export interface AtrOperationRequest {
    atrRequest: AtrRequest;
}

export interface BbandsOperationRequest {
    bbandsRequest: BbandsRequest;
}

export interface CciOperationRequest {
    cciRequest: CciRequest;
}

export interface EmaOperationRequest {
    emaRequest: EmaRequest;
}

export interface HeikenashiOperationRequest {
    heikenashiRequest: HeikenashiRequest;
}

export interface IchimokuOperationRequest {
    ichimokuRequest: IchimokuRequest;
}

export interface KeltnerOperationRequest {
    keltnerRequest: KeltnerRequest;
}

export interface MacdOperationRequest {
    macdRequest: MacdRequest;
}

export interface PivotOperationRequest {
    pivotRequest: PivotRequest;
}

export interface PsarOperationRequest {
    psarRequest: PsarRequest;
}

export interface RsiOperationRequest {
    rsiRequest: RsiRequest;
}

export interface SmaOperationRequest {
    smaRequest: SmaRequest;
}

export interface StochOperationRequest {
    stochRequest: StochRequest;
}

export interface SupertrendOperationRequest {
    supertrendRequest: SupertrendRequest;
}

export interface VolumemaOperationRequest {
    volumemaRequest: VolumemaRequest;
}

export interface VwapOperationRequest {
    vwapRequest: VwapRequest;
}

export interface WilliamsrOperationRequest {
    williamsrRequest: WilliamsrRequest;
}

export interface ZigzagOperationRequest {
    zigzagRequest: ZigzagRequest;
}

/**
 * 
 */
export class IndicatorsApi extends runtime.BaseAPI {

    /**
     * Calculate Average Directional Index (ADX)
     */
    async adxRaw(requestParameters: AdxOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Adx200ResponseInner>>> {
        if (requestParameters['adxRequest'] == null) {
            throw new runtime.RequiredError(
                'adxRequest',
                'Required parameter "adxRequest" was null or undefined when calling adx().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/adx`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AdxRequestToJSON(requestParameters['adxRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Adx200ResponseInnerFromJSON));
    }

    /**
     * Calculate Average Directional Index (ADX)
     */
    async adx(requestParameters: AdxOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Adx200ResponseInner>> {
        const response = await this.adxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Average True Range (ATR)
     */
    async atrRaw(requestParameters: AtrOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['atrRequest'] == null) {
            throw new runtime.RequiredError(
                'atrRequest',
                'Required parameter "atrRequest" was null or undefined when calling atr().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/atr`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AtrRequestToJSON(requestParameters['atrRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Calculate Average True Range (ATR)
     */
    async atr(requestParameters: AtrOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.atrRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Upper, Middle, and Lower bands.
     * Calculate Bollinger Bands
     */
    async bbandsRaw(requestParameters: BbandsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Bbands200ResponseInner>>> {
        if (requestParameters['bbandsRequest'] == null) {
            throw new runtime.RequiredError(
                'bbandsRequest',
                'Required parameter "bbandsRequest" was null or undefined when calling bbands().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/bbands`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BbandsRequestToJSON(requestParameters['bbandsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Bbands200ResponseInnerFromJSON));
    }

    /**
     * Returns Upper, Middle, and Lower bands.
     * Calculate Bollinger Bands
     */
    async bbands(requestParameters: BbandsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Bbands200ResponseInner>> {
        const response = await this.bbandsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Commodity Channel Index (CCI)
     */
    async cciRaw(requestParameters: CciOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['cciRequest'] == null) {
            throw new runtime.RequiredError(
                'cciRequest',
                'Required parameter "cciRequest" was null or undefined when calling cci().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/cci`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CciRequestToJSON(requestParameters['cciRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Calculate Commodity Channel Index (CCI)
     */
    async cci(requestParameters: CciOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.cciRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the EMA of the close prices.
     * Calculate Exponential Moving Average (EMA)
     */
    async emaRaw(requestParameters: EmaOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['emaRequest'] == null) {
            throw new runtime.RequiredError(
                'emaRequest',
                'Required parameter "emaRequest" was null or undefined when calling ema().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/ema`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EmaRequestToJSON(requestParameters['emaRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns the EMA of the close prices.
     * Calculate Exponential Moving Average (EMA)
     */
    async ema(requestParameters: EmaOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.emaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Heiken Ashi
     */
    async heikenashiRaw(requestParameters: HeikenashiOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Candle>>> {
        if (requestParameters['heikenashiRequest'] == null) {
            throw new runtime.RequiredError(
                'heikenashiRequest',
                'Required parameter "heikenashiRequest" was null or undefined when calling heikenashi().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/heikenashi`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: HeikenashiRequestToJSON(requestParameters['heikenashiRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CandleFromJSON));
    }

    /**
     * Calculate Heiken Ashi
     */
    async heikenashi(requestParameters: HeikenashiOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Candle>> {
        const response = await this.heikenashiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Ichimoku Cloud
     */
    async ichimokuRaw(requestParameters: IchimokuOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Ichimoku200ResponseInner>>> {
        if (requestParameters['ichimokuRequest'] == null) {
            throw new runtime.RequiredError(
                'ichimokuRequest',
                'Required parameter "ichimokuRequest" was null or undefined when calling ichimoku().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/ichimoku`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IchimokuRequestToJSON(requestParameters['ichimokuRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Ichimoku200ResponseInnerFromJSON));
    }

    /**
     * Calculate Ichimoku Cloud
     */
    async ichimoku(requestParameters: IchimokuOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Ichimoku200ResponseInner>> {
        const response = await this.ichimokuRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Keltner Channels
     */
    async keltnerRaw(requestParameters: KeltnerOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Bbands200ResponseInner>>> {
        if (requestParameters['keltnerRequest'] == null) {
            throw new runtime.RequiredError(
                'keltnerRequest',
                'Required parameter "keltnerRequest" was null or undefined when calling keltner().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/keltner`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KeltnerRequestToJSON(requestParameters['keltnerRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Bbands200ResponseInnerFromJSON));
    }

    /**
     * Calculate Keltner Channels
     */
    async keltner(requestParameters: KeltnerOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Bbands200ResponseInner>> {
        const response = await this.keltnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns MACD, Signal, and Histogram.
     * Calculate MACD
     */
    async macdRaw(requestParameters: MacdOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Macd200ResponseInner>>> {
        if (requestParameters['macdRequest'] == null) {
            throw new runtime.RequiredError(
                'macdRequest',
                'Required parameter "macdRequest" was null or undefined when calling macd().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/macd`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MacdRequestToJSON(requestParameters['macdRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Macd200ResponseInnerFromJSON));
    }

    /**
     * Returns MACD, Signal, and Histogram.
     * Calculate MACD
     */
    async macd(requestParameters: MacdOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Macd200ResponseInner>> {
        const response = await this.macdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Pivot Points
     */
    async pivotRaw(requestParameters: PivotOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Pivot200ResponseInner>>> {
        if (requestParameters['pivotRequest'] == null) {
            throw new runtime.RequiredError(
                'pivotRequest',
                'Required parameter "pivotRequest" was null or undefined when calling pivot().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/pivot`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PivotRequestToJSON(requestParameters['pivotRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Pivot200ResponseInnerFromJSON));
    }

    /**
     * Calculate Pivot Points
     */
    async pivot(requestParameters: PivotOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Pivot200ResponseInner>> {
        const response = await this.pivotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Parabolic SAR
     */
    async psarRaw(requestParameters: PsarOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['psarRequest'] == null) {
            throw new runtime.RequiredError(
                'psarRequest',
                'Required parameter "psarRequest" was null or undefined when calling psar().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/psar`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PsarRequestToJSON(requestParameters['psarRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Calculate Parabolic SAR
     */
    async psar(requestParameters: PsarOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.psarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the RSI of the close prices.
     * Calculate Relative Strength Index (RSI)
     */
    async rsiRaw(requestParameters: RsiOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['rsiRequest'] == null) {
            throw new runtime.RequiredError(
                'rsiRequest',
                'Required parameter "rsiRequest" was null or undefined when calling rsi().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/rsi`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RsiRequestToJSON(requestParameters['rsiRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns the RSI of the close prices.
     * Calculate Relative Strength Index (RSI)
     */
    async rsi(requestParameters: RsiOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.rsiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the SMA of the close prices.
     * Calculate Simple Moving Average (SMA)
     */
    async smaRaw(requestParameters: SmaOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['smaRequest'] == null) {
            throw new runtime.RequiredError(
                'smaRequest',
                'Required parameter "smaRequest" was null or undefined when calling sma().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/sma`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SmaRequestToJSON(requestParameters['smaRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns the SMA of the close prices.
     * Calculate Simple Moving Average (SMA)
     */
    async sma(requestParameters: SmaOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.smaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns %K and %D lines.
     * Calculate Stochastic Oscillator
     */
    async stochRaw(requestParameters: StochOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Stoch200ResponseInner>>> {
        if (requestParameters['stochRequest'] == null) {
            throw new runtime.RequiredError(
                'stochRequest',
                'Required parameter "stochRequest" was null or undefined when calling stoch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/stoch`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StochRequestToJSON(requestParameters['stochRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Stoch200ResponseInnerFromJSON));
    }

    /**
     * Returns %K and %D lines.
     * Calculate Stochastic Oscillator
     */
    async stoch(requestParameters: StochOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Stoch200ResponseInner>> {
        const response = await this.stochRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate SuperTrend
     */
    async supertrendRaw(requestParameters: SupertrendOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Supertrend200ResponseInner>>> {
        if (requestParameters['supertrendRequest'] == null) {
            throw new runtime.RequiredError(
                'supertrendRequest',
                'Required parameter "supertrendRequest" was null or undefined when calling supertrend().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/supertrend`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SupertrendRequestToJSON(requestParameters['supertrendRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(Supertrend200ResponseInnerFromJSON));
    }

    /**
     * Calculate SuperTrend
     */
    async supertrend(requestParameters: SupertrendOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Supertrend200ResponseInner>> {
        const response = await this.supertrendRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Simple Moving Average of Volume.
     * Calculate Volume MA
     */
    async volumemaRaw(requestParameters: VolumemaOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['volumemaRequest'] == null) {
            throw new runtime.RequiredError(
                'volumemaRequest',
                'Required parameter "volumemaRequest" was null or undefined when calling volumema().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/volumema`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VolumemaRequestToJSON(requestParameters['volumemaRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns Simple Moving Average of Volume.
     * Calculate Volume MA
     */
    async volumema(requestParameters: VolumemaOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.volumemaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate VWAP
     */
    async vwapRaw(requestParameters: VwapOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['vwapRequest'] == null) {
            throw new runtime.RequiredError(
                'vwapRequest',
                'Required parameter "vwapRequest" was null or undefined when calling vwap().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/vwap`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VwapRequestToJSON(requestParameters['vwapRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Calculate VWAP
     */
    async vwap(requestParameters: VwapOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.vwapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate Williams %R
     */
    async williamsrRaw(requestParameters: WilliamsrOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters['williamsrRequest'] == null) {
            throw new runtime.RequiredError(
                'williamsrRequest',
                'Required parameter "williamsrRequest" was null or undefined when calling williamsr().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/williamsr`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WilliamsrRequestToJSON(requestParameters['williamsrRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Calculate Williams %R
     */
    async williamsr(requestParameters: WilliamsrOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.williamsrRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculate ZigZag Indicator
     */
    async zigzagRaw(requestParameters: ZigzagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number | null>>> {
        if (requestParameters['zigzagRequest'] == null) {
            throw new runtime.RequiredError(
                'zigzagRequest',
                'Required parameter "zigzagRequest" was null or undefined when calling zigzag().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TickCatcher-Key"] = await this.configuration.apiKey("X-TickCatcher-Key"); // directToken authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-RapidAPI-Key"] = await this.configuration.apiKey("X-RapidAPI-Key"); // rapidapiKey authentication
        }


        let urlPath = `/api/indicators/zigzag`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ZigzagRequestToJSON(requestParameters['zigzagRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Calculate ZigZag Indicator
     */
    async zigzag(requestParameters: ZigzagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number | null>> {
        const response = await this.zigzagRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
